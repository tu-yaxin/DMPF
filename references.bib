@misc{cryptoeprint:2019/273,
      author = {Elette Boyle and Geoffroy Couteau and Niv Gilboa and Yuval Ishai},
      title = {Compressing Vector OLE},
      howpublished = {Cryptology ePrint Archive, Paper 2019/273},
      year = {2019},
      doi = {10.1145/3243734.3243868},
      note = {\url{https://eprint.iacr.org/2019/273}},
      url = {https://eprint.iacr.org/2019/273}
}

@InProceedings{EC:GilIsh14,
author="Gilboa, Niv
and Ishai, Yuval",
editor="Nguyen, Phong Q.
and Oswald, Elisabeth",
title="Distributed Point Functions and Their Applications",
booktitle="Advances in Cryptology -- EUROCRYPT 2014",
year="2014",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="640--658",
abstract="For x,y{\thinspace}∈{\thinspace}{\{}0,1{\}}*, the point function Px,yis defined by Px,y(x){\thinspace}={\thinspace}y and Px,y(x{\textasciiacutex}){\thinspace}={\thinspace}0|y| for all x{\textasciiacutex}{\thinspace}≠{\thinspace}x. We introduce the notion of a distributed point function (DPF), which is a keyed function family Fkwith the following property. Given x,y specifying a point function, one can efficiently generate a key pair (k0,k1) such that: (1) {\$}F{\_}{\{}k{\_}0{\}}{\backslash}oplus F{\_}{\{}k{\_}1{\}}=P{\_}{\{}x,y{\}}{\$}, and (2) each of k0 and k1 hides x and y. Our main result is an efficient construction of a DPF under the (minimal) assumption that a one-way function exists.",
isbn="978-3-642-55220-5"
}



@misc{cryptoeprint:2021/580,
      author = {Leo de Castro and Antigoni Polychroniadou},
      title = {Lightweight, Maliciously Secure Verifiable Function Secret Sharing},
      howpublished = {Cryptology ePrint Archive, Paper 2021/580},
      year = {2021},
      note = {\url{https://eprint.iacr.org/2021/580}},
      url = {https://eprint.iacr.org/2021/580}
}
@misc{cryptoeprint:2022/320,
      author = {Srinivasan Raghuraman and Peter Rindal},
      title = {Blazing Fast PSI from Improved OKVS and Subfield VOLE},
      howpublished = {Cryptology ePrint Archive, Paper 2022/320},
      year = {2022},
      note = {\url{https://eprint.iacr.org/2022/320}},
      url = {https://eprint.iacr.org/2022/320}
}
@misc{cryptoeprint:2021/883,
      author = {Gayathri Garimella and Benny Pinkas and Mike Rosulek and Ni Trieu and Avishay Yanai},
      title = {Oblivious Key-Value Stores and Amplification for Private Set Intersection},
      howpublished = {Cryptology ePrint Archive, Paper 2021/883},
      year = {2021},
      note = {\url{https://eprint.iacr.org/2021/883}},
      url = {https://eprint.iacr.org/2021/883}
}
@inproceedings{crypto-2022-32253,
  title={Programmable Distributed Point Functions},
  publisher={Springer-Verlag},
  author={Victor I. Kolobov and Elette Boyle and Niv Gilboa and Yuval Ishai},
  year=2022
}
@misc{cryptoeprint:2019/1084,
      author = {Phillipp Schoppmann and Adrià Gascón and Leonie Reichert and Mariana Raykova},
      title = {Distributed Vector-OLE: Improved Constructions and Implementation},
      howpublished = {Cryptology ePrint Archive, Paper 2019/1084},
      year = {2019},
      doi = {10.1145/3319535.3363228},
      note = {\url{https://eprint.iacr.org/2019/1084}},
      url = {https://eprint.iacr.org/2019/1084}
}

@misc{cryptoeprint:2019/448,
      author = {Elette Boyle and Geoffroy Couteau and Niv Gilboa and Yuval Ishai and Lisa Kohl and Peter Scholl},
      title = {Efficient Pseudorandom Correlation Generators: Silent OT Extension and More},
      howpublished = {Cryptology ePrint Archive, Paper 2019/448},
      year = {2019},
      note = {\url{https://eprint.iacr.org/2019/448}},
      url = {https://eprint.iacr.org/2019/448}
}

@misc{cryptoeprint:2022/1035,
      author = {Elette Boyle and Geoffroy Couteau and Niv Gilboa and Yuval Ishai and Lisa Kohl and Peter Scholl},
      title = {Efficient Pseudorandom Correlation Generators from Ring-LPN},
      howpublished = {Cryptology ePrint Archive, Paper 2022/1035},
      year = {2022},
      doi = {10.1007/978-3-030-56880-1_14},
      note = {\url{https://eprint.iacr.org/2022/1035}},
      url = {https://eprint.iacr.org/2022/1035}
}
@inproceedings{10.1145/73007.73010,
author = {Goldreich, O. and Levin, L. A.},
title = {A Hard-Core Predicate for All One-Way Functions},
year = {1989},
isbn = {0897913078},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/73007.73010},
doi = {10.1145/73007.73010},
abstract = {A central tool in constructing pseudorandom generators, secure encryption functions, and in other areas are “hard-core” predicates b of functions (permutations) undefined, discovered in [Blum Micali 82]. Such b(x) cannot be efficiently guessed (substantially better than 50-50) given only undefined(x). Both b, undefined are computable in polynomial time.[Yao 82] transforms any one-way function undefined into a more complicated one, undefined*, which has a hard-core predicate. The construction applies the original undefined to many small pieces of the input to undefined* just to get one “hard-core” bit. The security of this bit may be smaller than any constant positive power of the security of undefined. In fact, for inputs (to undefined*) of practical size, the pieces effected by undefined are so small that undefined can be inverted (and the “hard-core” bit computed) by exhaustive search.In this paper we show that every one-way function, padded to the form undefined(p, x) = (p, g(x)), ‖‖p‖‖ = ‖x‖, has by itself a hard-core predicate of the same (within a polynomial) security. Namely, we prove a conjecture of [Levin 87, sec. 5.6.2] that the scalar product of Boolean vectors p, x is a hard-core of every one-way function undefined(p, x) = (p, g(x)). The result extends to multiple (up to the logarithm of security) such bits and to any distribution on the x's for which undefined is hard to invert.},
booktitle = {Proceedings of the Twenty-First Annual ACM Symposium on Theory of Computing},
pages = {25–32},
numpages = {8},
location = {Seattle, Washington, USA},
series = {STOC '89}
}
@inproceedings{inproceedings,
author = {Zheng, Fangyu and Pan, Wuqiong and Lin, Jingqiang and Jing, Jiwu and Zhao, Yuan},
year = {2014},
month = {10},
pages = {},
title = {Exploiting the Floating-Point Computing Power of GPUs for RSA},
doi = {10.13140/RG.2.1.3694.7927}
}
@misc{cryptoeprint:2017/1142,
      author = {Sebastian Angel and Hao Chen and Kim Laine and Srinath Setty},
      title = {PIR with compressed queries and amortized query processing},
      howpublished = {Cryptology ePrint Archive, Paper 2017/1142},
      year = {2017},
      note = {\url{https://eprint.iacr.org/2017/1142}},
      url = {https://eprint.iacr.org/2017/1142}
}
@misc{cryptoeprint:2017/168,
      author = {Shay Gueron and Adam Langley and Yehuda Lindell},
      title = {AES-GCM-SIV: Specification and Analysis},
      howpublished = {Cryptology ePrint Archive, Paper 2017/168},
      year = {2017},
      note = {\url{https://eprint.iacr.org/2017/168}},
      url = {https://eprint.iacr.org/2017/168}
}

@misc{CCS:BoyGilIsh16,
      author = {Elette Boyle and Niv Gilboa and Yuval Ishai},
      title = {Function Secret Sharing: Improvements and Extensions},
      howpublished = {Cryptology ePrint Archive, Paper 2018/707},
      year = {2018},
      note = {\url{https://eprint.iacr.org/2018/707}},
      url = {https://eprint.iacr.org/2018/707}
}
@misc{cryptoeprint:2020/1599,
      author = {Samuel Dittmer and Yuval Ishai and Steve Lu and Rafail Ostrovsky and Mohamed Elsabagh and Nikolaos Kiourtis and Brian Schulte and Angelos Stavrou},
      title = {Function Secret Sharing for PSI-CA: With Applications to Private Contact Tracing},
      howpublished = {Cryptology ePrint Archive, Paper 2020/1599},
      year = {2020},
      note = {\url{https://eprint.iacr.org/2020/1599}},
      url = {https://eprint.iacr.org/2020/1599}
}
@misc{cryptoeprint:2020/193,
      author = {Benny Pinkas and Mike Rosulek and Ni Trieu and Avishay Yanai},
      title = {PSI from PaXoS:  Fast, Malicious Private Set Intersection},
      howpublished = {Cryptology ePrint Archive, Paper 2020/193},
      year = {2020},
      note = {\url{https://eprint.iacr.org/2020/193}},
      url = {https://eprint.iacr.org/2020/193}
}
@misc{dillinger_ribbon_2021,
	title = {Ribbon filter: practically smaller than {Bloom} and {Xor}},
	shorttitle = {Ribbon filter},
	url = {http://arxiv.org/abs/2103.02515},
	abstract = {Filter data structures over-approximate a set of hashable keys, i.e. set membership queries may incorrectly come out positive. A filter with false positive rate \$f {\textbackslash}in (0,1]\$ is known to require \${\textbackslash}ge {\textbackslash}log\_2(1/f)\$ bits per key. At least for larger \$f {\textbackslash}ge 2{\textasciicircum}\{-4\}\$, existing practical filters require a space overhead of at least 20\% with respect to this information-theoretic bound. We introduce the Ribbon filter: a new filter for static sets with a broad range of configurable space overheads and false positive rates with competitive speed over that range, especially for larger \$f {\textbackslash}ge 2{\textasciicircum}\{-7\}\$. In many cases, Ribbon is faster than existing filters for the same space overhead, or can achieve space overhead below 10\% with some additional CPU time. An experimental Ribbon design with load balancing can even achieve space overheads below 1\%. A Ribbon filter resembles an Xor filter modified to maximize locality and is constructed by solving a band-like linear system over Boolean variables. In previous work, Dietzfelbinger and Walzer describe this linear system and an efficient Gaussian solver. We present and analyze a faster, more adaptable solving process we call "Rapid Incremental Boolean Banding ON the fly," which resembles hash table construction. We also present and analyze an attractive Ribbon variant based on making the linear system homogeneous, and describe several more practical enhancements.},
	urldate = {2022-10-19},
	publisher = {arXiv},
	author = {Dillinger, Peter C. and Walzer, Stefan},
	month = mar,
	year = {2021},
	note = {arXiv:2103.02515 [cs]},
	keywords = {Computer Science - Data Structures and Algorithms, Computer Science - Databases, E.1, E.2},
}
@misc{dietzfelbinger_efficient_2019,
	title = {Efficient {Gauss} {Elimination} for {Near}-{Quadratic} {Matrices} with {One} {Short} {Random} {Block} per {Row}, with {Applications}},
	url = {http://arxiv.org/abs/1907.04750},
	abstract = {In this paper we identify a new class of sparse near-quadratic random Boolean matrices that have full row rank over \${\textbackslash}mathbb\{F\}\_2={\textbackslash}\{0,1{\textbackslash}\}\$ with high probability and can be transformed into echelon form in almost linear time by a simple version of Gauss elimination. The random matrix with dimensions \$n(1-{\textbackslash}varepsilon) {\textbackslash}times n\$ is generated as follows: In each row, identify a block of length \$L=O(({\textbackslash}log n)/{\textbackslash}varepsilon)\$ at a random position. The entries outside the block are 0, the entries inside the block are given by fair coin tosses. Sorting the rows according to the positions of the blocks transforms the matrix into a kind of band matrix, on which, as it turns out, Gauss elimination works very efficiently with high probability. For the proof, the effects of Gauss elimination are interpreted as a ("coin-flipping") variant of Robin Hood hashing, whose behaviour can be captured in terms of a simple Markov model from queuing theory. Bounds for expected construction time and high success probability follow from results in this area. By employing hashing, this matrix family leads to a new implementation of a retrieval data structure, which represents an arbitrary function \$f{\textbackslash}colon S {\textbackslash}to {\textbackslash}\{0,1{\textbackslash}\}\$ for some set \$S\$ of \$m=(1-{\textbackslash}varepsilon)n\$ keys. It requires \$m/(1-{\textbackslash}varepsilon)\$ bits of space, construction takes \$O(m/{\textbackslash}varepsilon{\textasciicircum}2\$) expected time on a word RAM, while queries take \$O(1/{\textbackslash}varepsilon)\$ time and access only one contiguous segment of \$O(({\textbackslash}log m)/{\textbackslash}varepsilon)\$ bits in the representation. The method is competitive with state-of-the-art methods. By well-established methods the retrieval data structure leads to efficient constructions of (static) perfect hash functions and (static) Bloom filters with almost optimal space and very local storage access patterns for queries.},
	urldate = {2022-10-19},
	publisher = {arXiv},
	author = {Dietzfelbinger, Martin and Walzer, Stefan},
	month = jul,
	year = {2019},
	note = {arXiv:1907.04750 [cs]},
}
@inproceedings{10.1145/1007352.1007396,
author = {Ishai, Yuval and Kushilevitz, Eyal and Ostrovsky, Rafail and Sahai, Amit},
title = {Batch Codes and Their Applications},
year = {2004},
isbn = {1581138520},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1007352.1007396},
doi = {10.1145/1007352.1007396},
abstract = {A batch code encodes a string x into an m-tuple of strings, called buckets, such that each batch of k bits from x can be decoded by reading at most one (more generally, t) bits from each bucket. Batch codes can be viewed as relaxing several combinatorial objects, including expanders and locally decodable codes. We initiate the study of these codes by presenting some constructions, connections with other problems, and lower bounds. We also demonstrate the usefulness of batch codes by presenting two types of applications: trading maximal load for storage in certain load-balancing scenarios, and amortizing the computational cost of private information retrieval (PIR) and related cryptographic protocols.},
booktitle = {Proceedings of the Thirty-Sixth Annual ACM Symposium on Theory of Computing},
pages = {262–271},
numpages = {10},
keywords = {distributed storage, private information retrieval, locally decodable codes, load balancing, coding},
location = {Chicago, IL, USA},
series = {STOC '04}
}

@InProceedings{10.1007/3-540-44676-1_10,
author="Pagh, Rasmus
and Rodler, Flemming Friche",
editor="auf der Heide, Friedhelm Meyer",
title="Cuckoo Hashing",
booktitle="Algorithms --- ESA 2001",
year="2001",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="121--133",
abstract="We present a simple and efficient dictionary with worst case constant lookup time, equaling the theoretical performance of the classic dynamic perfect hashing scheme of Dietzfelbinger et al. The space usage is similar to that of binary search trees, i.e., three words per key on average. The practicality of the scheme is backed by extensive experiments and comparisons with known methods, showing it to be quite competitive also in the average case.",
isbn="978-3-540-44676-7"
}


@inproceedings{chen_fast_2017,
	address = {New York, NY, USA},
	series = {{CCS} '17},
	title = {Fast {Private} {Set} {Intersection} from {Homomorphic} {Encryption}},
	isbn = {978-1-4503-4946-8},
	url = {https://dl.acm.org/doi/10.1145/3133956.3134061},
	doi = {10.1145/3133956.3134061},
	abstract = {Private Set Intersection (PSI) is a cryptographic technique that allows two parties to compute the intersection of their sets without revealing anything except the intersection. We use fully homomorphic encryption to construct a fast PSI protocol with a small communication overhead that works particularly well when one of the two sets is much smaller than the other, and is secure against semi-honest adversaries. The most computationally efficient PSI protocols have been constructed using tools such as hash functions and oblivious transfer, but a potential limitation with these approaches is the communication complexity, which scales linearly with the size of the larger set. This is of particular concern when performing PSI between a constrained device (cellphone) holding a small set, and a large service provider (e.g. WhatsApp), such as in the Private Contact Discovery application. Our protocol has communication complexity linear in the size of the smaller set, and logarithmic in the larger set. More precisely, if the set sizes are Ny {\textless} Nx, we achieve a communication overhead of O(Ny log Nx). Our running-time-optimized benchmarks show that it takes 36 seconds of online-computation, 71 seconds of non-interactive (receiver-independent) pre-processing, and only 12.5MB of round trip communication to intersect five thousand 32-bit strings with 16 million 32-bit strings. Compared to prior works, this is roughly a 38--115x reduction in communication with minimal difference in computational overhead.},
	urldate = {2023-05-05},
	booktitle = {Proceedings of the 2017 {ACM} {SIGSAC} {Conference} on {Computer} and {Communications} {Security}},
	publisher = {Association for Computing Machinery},
	author = {Chen, Hao and Laine, Kim and Rindal, Peter},
	month = oct,
	year = {2017},
	keywords = {fully homomorphic encryption, private set intersection},
	pages = {1243--1255},
}
