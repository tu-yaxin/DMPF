@misc{cryptoeprint:2019/273,
      author = {Elette Boyle and Geoffroy Couteau and Niv Gilboa and Yuval Ishai},
      title = {Compressing Vector OLE},
      howpublished = {Cryptology ePrint Archive, Paper 2019/273},
      year = {2019},
      doi = {10.1145/3243734.3243868},
      note = {\url{https://eprint.iacr.org/2019/273}},
      url = {https://eprint.iacr.org/2019/273}
}

@InProceedings{EC:GilIsh14,
author="Gilboa, Niv
and Ishai, Yuval",
editor="Nguyen, Phong Q.
and Oswald, Elisabeth",
title="Distributed Point Functions and Their Applications",
booktitle="Advances in Cryptology -- EUROCRYPT 2014",
year="2014",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="640--658",
abstract="For x,y{\thinspace}∈{\thinspace}{\{}0,1{\}}*, the point function Px,yis defined by Px,y(x){\thinspace}={\thinspace}y and Px,y(x{\textasciiacutex}){\thinspace}={\thinspace}0|y| for all x{\textasciiacutex}{\thinspace}≠{\thinspace}x. We introduce the notion of a distributed point function (DPF), which is a keyed function family Fkwith the following property. Given x,y specifying a point function, one can efficiently generate a key pair (k0,k1) such that: (1) {\$}F{\_}{\{}k{\_}0{\}}{\backslash}oplus F{\_}{\{}k{\_}1{\}}=P{\_}{\{}x,y{\}}{\$}, and (2) each of k0 and k1 hides x and y. Our main result is an efficient construction of a DPF under the (minimal) assumption that a one-way function exists.",
isbn="978-3-642-55220-5"
}



@misc{cryptoeprint:2021/580,
      author = {Leo de Castro and Antigoni Polychroniadou},
      title = {Lightweight, Maliciously Secure Verifiable Function Secret Sharing},
      howpublished = {Cryptology ePrint Archive, Paper 2021/580},
      year = {2021},
      note = {\url{https://eprint.iacr.org/2021/580}},
      url = {https://eprint.iacr.org/2021/580}
}
@misc{cryptoeprint:2022/320,
      author = {Srinivasan Raghuraman and Peter Rindal},
      title = {Blazing Fast PSI from Improved OKVS and Subfield VOLE},
      howpublished = {Cryptology ePrint Archive, Paper 2022/320},
      year = {2022},
      note = {\url{https://eprint.iacr.org/2022/320}},
      url = {https://eprint.iacr.org/2022/320}
}
@misc{cryptoeprint:2021/883,
      author = {Gayathri Garimella and Benny Pinkas and Mike Rosulek and Ni Trieu and Avishay Yanai},
      title = {Oblivious Key-Value Stores and Amplification for Private Set Intersection},
      howpublished = {Cryptology ePrint Archive, Paper 2021/883},
      year = {2021},
      note = {\url{https://eprint.iacr.org/2021/883}},
      url = {https://eprint.iacr.org/2021/883}
}
@inproceedings{crypto-2022-32253,
  title={Programmable Distributed Point Functions},
  publisher={Springer-Verlag},
  author={Victor I. Kolobov and Elette Boyle and Niv Gilboa and Yuval Ishai},
  year=2022
}
@misc{cryptoeprint:2019/1084,
      author = {Phillipp Schoppmann and Adrià Gascón and Leonie Reichert and Mariana Raykova},
      title = {Distributed Vector-OLE: Improved Constructions and Implementation},
      howpublished = {Cryptology ePrint Archive, Paper 2019/1084},
      year = {2019},
      doi = {10.1145/3319535.3363228},
      note = {\url{https://eprint.iacr.org/2019/1084}},
      url = {https://eprint.iacr.org/2019/1084}
}

@misc{cryptoeprint:2019/448,
      author = {Elette Boyle and Geoffroy Couteau and Niv Gilboa and Yuval Ishai and Lisa Kohl and Peter Scholl},
      title = {Efficient Pseudorandom Correlation Generators: Silent OT Extension and More},
      howpublished = {Cryptology ePrint Archive, Paper 2019/448},
      year = {2019},
      note = {\url{https://eprint.iacr.org/2019/448}},
      url = {https://eprint.iacr.org/2019/448}
}

@misc{cryptoeprint:2022/1035,
      author = {Elette Boyle and Geoffroy Couteau and Niv Gilboa and Yuval Ishai and Lisa Kohl and Peter Scholl},
      title = {Efficient Pseudorandom Correlation Generators from Ring-LPN},
      howpublished = {Cryptology ePrint Archive, Paper 2022/1035},
      year = {2022},
      doi = {10.1007/978-3-030-56880-1_14},
      note = {\url{https://eprint.iacr.org/2022/1035}},
      url = {https://eprint.iacr.org/2022/1035}
}
@inproceedings{10.1145/73007.73010,
author = {Goldreich, O. and Levin, L. A.},
title = {A Hard-Core Predicate for All One-Way Functions},
year = {1989},
isbn = {0897913078},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/73007.73010},
doi = {10.1145/73007.73010},
abstract = {A central tool in constructing pseudorandom generators, secure encryption functions, and in other areas are “hard-core” predicates b of functions (permutations) undefined, discovered in [Blum Micali 82]. Such b(x) cannot be efficiently guessed (substantially better than 50-50) given only undefined(x). Both b, undefined are computable in polynomial time.[Yao 82] transforms any one-way function undefined into a more complicated one, undefined*, which has a hard-core predicate. The construction applies the original undefined to many small pieces of the input to undefined* just to get one “hard-core” bit. The security of this bit may be smaller than any constant positive power of the security of undefined. In fact, for inputs (to undefined*) of practical size, the pieces effected by undefined are so small that undefined can be inverted (and the “hard-core” bit computed) by exhaustive search.In this paper we show that every one-way function, padded to the form undefined(p, x) = (p, g(x)), ‖‖p‖‖ = ‖x‖, has by itself a hard-core predicate of the same (within a polynomial) security. Namely, we prove a conjecture of [Levin 87, sec. 5.6.2] that the scalar product of Boolean vectors p, x is a hard-core of every one-way function undefined(p, x) = (p, g(x)). The result extends to multiple (up to the logarithm of security) such bits and to any distribution on the x's for which undefined is hard to invert.},
booktitle = {Proceedings of the Twenty-First Annual ACM Symposium on Theory of Computing},
pages = {25–32},
numpages = {8},
location = {Seattle, Washington, USA},
series = {STOC '89}
}
@inproceedings{inproceedings,
author = {Zheng, Fangyu and Pan, Wuqiong and Lin, Jingqiang and Jing, Jiwu and Zhao, Yuan},
year = {2014},
month = {10},
pages = {},
title = {Exploiting the Floating-Point Computing Power of GPUs for RSA},
doi = {10.13140/RG.2.1.3694.7927}
}
@misc{cryptoeprint:2017/1142,
      author = {Sebastian Angel and Hao Chen and Kim Laine and Srinath Setty},
      title = {PIR with compressed queries and amortized query processing},
      howpublished = {Cryptology ePrint Archive, Paper 2017/1142},
      year = {2017},
      note = {\url{https://eprint.iacr.org/2017/1142}},
      url = {https://eprint.iacr.org/2017/1142}
}
@misc{cryptoeprint:2017/168,
      author = {Shay Gueron and Adam Langley and Yehuda Lindell},
      title = {AES-GCM-SIV: Specification and Analysis},
      howpublished = {Cryptology ePrint Archive, Paper 2017/168},
      year = {2017},
      note = {\url{https://eprint.iacr.org/2017/168}},
      url = {https://eprint.iacr.org/2017/168}
}

@misc{CCS:BoyGilIsh16,
      author = {Elette Boyle and Niv Gilboa and Yuval Ishai},
      title = {Function Secret Sharing: Improvements and Extensions},
      howpublished = {Cryptology ePrint Archive, Paper 2018/707},
      year = {2018},
      note = {\url{https://eprint.iacr.org/2018/707}},
      url = {https://eprint.iacr.org/2018/707}
}
@misc{cryptoeprint:2020/1599,
      author = {Samuel Dittmer and Yuval Ishai and Steve Lu and Rafail Ostrovsky and Mohamed Elsabagh and Nikolaos Kiourtis and Brian Schulte and Angelos Stavrou},
      title = {Function Secret Sharing for PSI-CA: With Applications to Private Contact Tracing},
      howpublished = {Cryptology ePrint Archive, Paper 2020/1599},
      year = {2020},
      note = {\url{https://eprint.iacr.org/2020/1599}},
      url = {https://eprint.iacr.org/2020/1599}
}
@misc{cryptoeprint:2020/193,
      author = {Benny Pinkas and Mike Rosulek and Ni Trieu and Avishay Yanai},
      title = {PSI from PaXoS:  Fast, Malicious Private Set Intersection},
      howpublished = {Cryptology ePrint Archive, Paper 2020/193},
      year = {2020},
      note = {\url{https://eprint.iacr.org/2020/193}},
      url = {https://eprint.iacr.org/2020/193}
}
@misc{dillinger_ribbon_2021,
	title = {Ribbon filter: practically smaller than {Bloom} and {Xor}},
	shorttitle = {Ribbon filter},
	url = {http://arxiv.org/abs/2103.02515},
	abstract = {Filter data structures over-approximate a set of hashable keys, i.e. set membership queries may incorrectly come out positive. A filter with false positive rate \$f {\textbackslash}in (0,1]\$ is known to require \${\textbackslash}ge {\textbackslash}log\_2(1/f)\$ bits per key. At least for larger \$f {\textbackslash}ge 2{\textasciicircum}\{-4\}\$, existing practical filters require a space overhead of at least 20\% with respect to this information-theoretic bound. We introduce the Ribbon filter: a new filter for static sets with a broad range of configurable space overheads and false positive rates with competitive speed over that range, especially for larger \$f {\textbackslash}ge 2{\textasciicircum}\{-7\}\$. In many cases, Ribbon is faster than existing filters for the same space overhead, or can achieve space overhead below 10\% with some additional CPU time. An experimental Ribbon design with load balancing can even achieve space overheads below 1\%. A Ribbon filter resembles an Xor filter modified to maximize locality and is constructed by solving a band-like linear system over Boolean variables. In previous work, Dietzfelbinger and Walzer describe this linear system and an efficient Gaussian solver. We present and analyze a faster, more adaptable solving process we call "Rapid Incremental Boolean Banding ON the fly," which resembles hash table construction. We also present and analyze an attractive Ribbon variant based on making the linear system homogeneous, and describe several more practical enhancements.},
	urldate = {2022-10-19},
	publisher = {arXiv},
	author = {Dillinger, Peter C. and Walzer, Stefan},
	month = mar,
	year = {2021},
	note = {arXiv:2103.02515 [cs]},
	keywords = {Computer Science - Data Structures and Algorithms, Computer Science - Databases, E.1, E.2},
}
@misc{dietzfelbinger_efficient_2019,
	title = {Efficient {Gauss} {Elimination} for {Near}-{Quadratic} {Matrices} with {One} {Short} {Random} {Block} per {Row}, with {Applications}},
	url = {http://arxiv.org/abs/1907.04750},
	abstract = {In this paper we identify a new class of sparse near-quadratic random Boolean matrices that have full row rank over \${\textbackslash}mathbb\{F\}\_2={\textbackslash}\{0,1{\textbackslash}\}\$ with high probability and can be transformed into echelon form in almost linear time by a simple version of Gauss elimination. The random matrix with dimensions \$n(1-{\textbackslash}varepsilon) {\textbackslash}times n\$ is generated as follows: In each row, identify a block of length \$L=O(({\textbackslash}log n)/{\textbackslash}varepsilon)\$ at a random position. The entries outside the block are 0, the entries inside the block are given by fair coin tosses. Sorting the rows according to the positions of the blocks transforms the matrix into a kind of band matrix, on which, as it turns out, Gauss elimination works very efficiently with high probability. For the proof, the effects of Gauss elimination are interpreted as a ("coin-flipping") variant of Robin Hood hashing, whose behaviour can be captured in terms of a simple Markov model from queuing theory. Bounds for expected construction time and high success probability follow from results in this area. By employing hashing, this matrix family leads to a new implementation of a retrieval data structure, which represents an arbitrary function \$f{\textbackslash}colon S {\textbackslash}to {\textbackslash}\{0,1{\textbackslash}\}\$ for some set \$S\$ of \$m=(1-{\textbackslash}varepsilon)n\$ keys. It requires \$m/(1-{\textbackslash}varepsilon)\$ bits of space, construction takes \$O(m/{\textbackslash}varepsilon{\textasciicircum}2\$) expected time on a word RAM, while queries take \$O(1/{\textbackslash}varepsilon)\$ time and access only one contiguous segment of \$O(({\textbackslash}log m)/{\textbackslash}varepsilon)\$ bits in the representation. The method is competitive with state-of-the-art methods. By well-established methods the retrieval data structure leads to efficient constructions of (static) perfect hash functions and (static) Bloom filters with almost optimal space and very local storage access patterns for queries.},
	urldate = {2022-10-19},
	publisher = {arXiv},
	author = {Dietzfelbinger, Martin and Walzer, Stefan},
	month = jul,
	year = {2019},
	note = {arXiv:1907.04750 [cs]},
}